プロジェクトライブラリの選定理由

このプロジェクトで使用されている主要なPythonライブラリとその選定理由です。

■ Webアプリケーションの構築

- Flask
  - 役割: Webフレームワーク
  - 理由: PythonでWebアプリケーション（サーバー）を簡単に構築するために使用します。ユーザーのブラウザからのリクエスト（画像のアップロードなど）を受け取り、処理結果（HTML画面や画像データ）を返す役割を担います。このシステムの「骨格」となる部分です。

■ 画像処理とデータ変換

- opencv-python-headless
  - 役割: コンピュータビジョンライブラリ
  - 理由: 画像の読み込み、変換、保存といった中心的な処理に使用しています。具体的には、アップロードされたファイルデータを画像形式に変換し、ディープラーニングモデルが扱える形式に整え、最後に処理後のデータを再び画像ファイルとして書き出すために利用しています。`headless`版は、GUI（画面表示）機能を含まないサーバー向けのバージョンであり、今回のシステムに最適です。

- Pillow
  - 役割: 画像処理ライブラリ
  - 理由: Pythonで画像を扱う際の標準的なライブラリです。FlaskやOpenCVの内部で画像データを扱う際に補助的に利用されることがあるため、画像処理プロジェクトの基本的なライブラリとして含めています。

■ ディープラーニングモデルの利用

- torch & torchvision
  - 役割: ディープラーニングフレームワーク
  - 理由: 「学習済みモデルを使いたい」というご要望にお応えするために追加しました。
    - `torch`: DnCNNのようなニューラルネットワークの構築と実行を可能にするPyTorchのコアライブラリです。画像のノイズ除去を行うモデルの計算処理そのものを担当します。
    - `torchvision`: PyTorchで画像処理タスクを行うための補助ライブラリです。今回は直接使用していませんが、PyTorchで画像を扱う際にはほぼ必須のライブラリとなります。

# 画像解析ツールの技術スタックと実行ファイル化の解説

## 概要

このアプリケーションは、元々は「PythonのWebサーバーをターミナルで起動し、ユーザーが手動でWebブラウザで指定URLにアクセスする」という形式でした。

これを、「ユーザーがダブルクリックするだけで起動し、自動でブラウザが立ち上がる」というスタンドアロンのデスクトップアプリケーション形式に変換しました。これにより、PythonがインストールされていないPCでも動作し、専門知識がない人でも簡単に利用できるようになりました。

以下に、それを実現した主要な技術と仕組みを解説します。

---

## 主要技術スタック

- **Python**: アプリケーションの基本言語。
- **Flask**: Webアプリケーションの骨格を作るためのフレームワーク。画面表示（HTML）と内部ロジックを連携させます。
- **Waitress**: Python製のWSGIサーバー。開発用の簡易サーバーではなく、より安定した本番環境グレードのサーバーとして利用しました。
- **PyInstaller**: Pythonスクリプトとそれに関連する全てのファイル（ライブラリ、HTML、CSS等）を、単一の実行可能ファイル（`.exe`）にパッケージングするためのツール。今回の「実行ファイル化」の最重要技術です。

---

## 実行ファイル化の仕組み (なぜ`.exe`だけで動くのか？)

### 1. `PyInstaller`によるパッケージング

`app.exe`が自己完結して動作する最大の理由は、`PyInstaller`がアプリケーションの実行に必要な**全ての部品をファイル内部に梱包（パッケージング）している**からです。

- **Python実行環境の同梱**: 実行先のPCにPythonがインストールされていなくても動くように、`app.exe`内には小規模なPython実行環境（インタプリタ）そのものが含まれています。
- **ライブラリの同梱**: `pip`でインストールした`Flask`や`Waitress`などのライブラリも全て`app.exe`内に取り込まれます。
- **静的ファイル（HTML/CSS/JS）の同梱**: アプリケーションの見た目や動きを定義する`templates`フォルダ（HTMLファイル）と`static`フォルダ（CSS, JSファイル）も、`pyinstaller`コマンド実行時に`--add-data`オプションで指定することで、`app.exe`内に含めました。

これにより、`app.exe`は外部のファイルに一切依存しない、自己完結したプログラムとなります。

### 2. 実行時のファイル展開とパス解決

`app.exe`をダブルクリックすると、内部では以下のことが起きています。

1.  **一時フォルダへの展開**: `app.exe`は、PCの一時フォルダ（Temp）に、自身が内包しているPython実行環境、ライブラリ、HTML/CSSファイルなどを一時的に展開します。この一時フォルダの場所は`_MEIPASS`という特殊な変数で知ることができます。
2.  **パスの動的解決**: 修正後の`app.py`には、自分が実行ファイルとして起動されたのか、通常のPythonスクリプトとして起動されたのかを判別するロジックを追加しました。
    ```python
    if getattr(sys, 'frozen', False):
        # 実行ファイルとして起動された場合
        base_dir = sys._MEIPASS
        # HTML/CSSファイルの場所を一時フォルダ内に指定
        template_folder = os.path.join(base_dir, 'templates')
        static_folder = os.path.join(base_dir, 'static')
        app = Flask(__name__, template_folder=template_folder, static_folder=static_folder)
    else:
        # 通常のスクリプトとして起動された場合
        app = Flask(__name__)
    ```
    このコードにより、実行ファイルは**どこに置かれても**、自分自身が展開した一時フォルダの中から正しくHTMLやCSSファイルを見つけ出すことができます。これが、`app.exe`をデスクトップなど好きな場所に移動させても動作する理由です。

### 3. Webサーバーの内蔵とブラウザの自動起動

- **サーバーの役割**: `app.exe`は、内部で`Waitress`というWebサーバーを起動します。これは表には見えませんが、バックグラウンドで動いており、ブラウザからのアクセスを待ち受けています。
- **自動化によるUX向上**: アプリケーションが起動すると、Pythonの`webbrowser`ライブラリが呼び出され、自動的にデフォルトのWebブラウザが立ち上がり、`http://127.0.0.1:8080`にアクセスします。これにより、ユーザーは「`.exe`をダブルクリックする」という操作だけで、すぐにアプリケーションを使い始めることができます。

---

## 結論

`PyInstaller`がPython実行環境と全依存ファイルを単一ファイルにまとめ、修正された`app.py`が実行時のファイルパスを賢く解決することで、**Web技術を使いながらも、見た目や使い勝手は完全にスタンドアロンのデスクトップアプリケーション**として振る舞うことが可能になりました。これが、`app.exe`ファイル一つで、どのPCでも手軽にアプリケーションを起動できる仕組みの全体像です。

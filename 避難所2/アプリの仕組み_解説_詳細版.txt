# アプリケーションアーキテクチャ概要

このアプリケーションは、ローカルで実行されるPythonプロセスをサーバー、Webブラウザをクライアントとするクライアントサーバーモデルを採用している。アプリケーションの主要なロジックは、ほぼすべてクライアントサイド（ブラウザ側）に実装されている。

---

### 1. バックエンド (`app.py`)

バックエンドは、軽量なWebサーバーとして機能し、フロントエンドアセットの配信と、自身のライフサイクル管理のみ責務を持つ。

#### ◆ スタック
- **Python 3**: 実行言語
- **Flask**: Webフレームワーク。ルーティング定義に使用。
- **Waitress**: WSGIサーバー。Flaskアプリケーションをホストする。

#### ◆ 責務
1.  **静的ファイル配信**: ルートURL (`/`) へのリクエストに対し `index.html` を配信する。また、`static` フォルダ内のCSSやJavaScriptファイルもブラウザからのリクエストに応じて配信する。
2.  **ブラウザ起動**: 起動時にシステムのデフォルトブラウザを立ち上げ、自身のホストするURL (`http://127.0.0.1:8080`) を開く。
3.  **シャットダウンAPI**: `/shutdown` エンドポイントを提供する。このエンドポイントにPOSTリクエストが送られると、`os.kill(os.getpid(), signal.SIGTERM)` を実行し、自身のプロセスを終了させる。これにより、クライアントサイドからの操作でアプリケーション全体を閉じることが可能になる。

#### ◆ 使用しているPythonライブラリの詳細

-   **`Flask` (Webフレームワーク)**
    *   **役割**: アプリケーションのバックエンド部分の基盤となるWebフレームワークだ。このアプリでは、ブラウザからのHTTPリクエスト（例: アプリのトップページにアクセスするリクエスト）を受け取り、それに応じたHTMLファイルや静的ファイル（CSS, JavaScriptなど）をブラウザに返信するルーティング処理を定義している。また、アプリを終了させるための特別な `/shutdown` エンドポイントも提供している。
    *   **重要性**: 軽量でシンプルなので、今回のような「デスクトップアプリのUIとしてWebページを使う」という用途に適している。

-   **`Waitress` (WSGIサーバー)**
    *   **役割**: `Flask`で作成したWebアプリケーションは、そのままではWebサーバーとして機能しない。`Waitress`は、`Flask`アプリケーションを実際にWebサーバーとして動作させるための「WSGI (Web Server Gateway Interface) サーバー」だ。開発中はFlaskに付属のシンプルな開発用サーバーでも動かせるが、`Waitress`を使うことで、より安定して、複数のリクエストを処理できるような、本番に近い環境でアプリケーションを動かすことができる。
    *   **重要性**: `app.exe`として配布する際に、安定してWebページを提供するための実行環境となる。

-   **`webbrowser` (標準ライブラリ)**
    *   **役割**: Pythonの標準ライブラリの一つで、ユーザーのデフォルトWebブラウザをプログラムから制御するために使われる。
    *   **重要性**: アプリケーション起動時に、作成したWebUIのURLを自動的にブラウザで開くために利用している。ユーザーが手動でURLを入力する手間を省いている。

-   **`os` (標準ライブラリ)**
    *   **役割**: Pythonの標準ライブラリの一つで、オペレーティングシステム（OS）の機能と対話するために使われる。ファイルパスの操作やプロセスの管理など、OSレベルの操作が可能だ。
    *   **重要性**: `/shutdown` エンドポイントで、自身のプロセスID (`os.getpid()`) を取得し、そのプロセスを終了させる (`os.kill`) ために使用している。これにより、ブラウザの閉じるボタンでアプリ全体を終了させる機能を実現している。

-   **`signal` (標準ライブラリ)**
    *   **役割**: Pythonの標準ライブラリの一つで、OSからのシグナル（割り込み信号）を処理するために使われる。プロセスに対して終了や一時停止などの指示を送ることができる。
    *   **重要性**: `os.kill` と組み合わせて、プロセスに終了シグナル (`signal.SIGTERM`) を送るために使用している。

---

### 2. フロントエンド (`script.js` / ブラウザ)

アプリケーションのコア機能、UI、画像処理ロジックはすべてクライアントサイドで実行される。

#### ◆ スタック
- **HTML5**: アプリケーションの構造（DOM）を定義。`<canvas>` 要素が画像処理の核となる。
- **CSS3 / Bootstrap 5**: UIのスタイリング。
- **JavaScript (ES6+)**: アプリケーションの全ロジックを実装。
- **UTIF.js**: サードパーティのTIFFデコードライブラリ。

#### ◆ 主なロジックと責務 (JavaScriptの動作詳細)

1.  **初期化 (`DOMContentLoaded`)**
    - HTMLドキュメントが完全に読み込まれ、解析された時点で処理を開始する。
    - `document.getElementById` を使い、後で操作する必要があるすべてのHTML要素（ボタン、スライダー、キャンバスなど）への参照を変数に格納（キャッシュ）する。これにより、操作のたびにDOMツリーを検索する必要がなくなり、パフォーマンスが向上する。
    - アプリケーションの状態を保持するためのグローバル変数（`originalImage`, `currentMode`, `scale`, `measureWizardStep` など）を初期化する。

2.  **画像読み込みロジック (`imageLoader` の `change` イベント)**
    - ユーザーがファイルを選択すると、このイベントが発火する。
    - **ファイル形式の判定**: 選択されたファイルの拡張子やMIMEタイプをチェックし、TIFFかそれ以外の標準的な画像（JPEG, PNGなど）かを判断する。
    - **TIFF画像の場合**:
        1.  `FileReader.readAsArrayBuffer` を使い、ファイルをバイナリデータ（`ArrayBuffer`）として読み込む。
        2.  そのバッファを、導入した `UTIF.js` ライブラリの `UTIF.decode()` に渡して、TIFFの構造情報（IFD）を解析する。
        3.  `UTIF.decodeImage()` で画像データそのものをデコードし、`UTIF.toRGBA8()` でキャンバスが扱えるRGBA形式のピクセル配列に変換する。
        4.  このピクセル配列を `ImageData` オブジェクトとして、一時的にメモリ上に作成したキャンバスに `putImageData` で描画する。
        5.  最終的に、その一時キャンバスの内容を `toDataURL('image/png')` を使ってPNG形式のData URLに変換する。このURLを `originalImage.src` に設定することで、ブラウザネイティブの `Image` オブジェクトとして扱えるようになり、後続の処理を共通化している。
    - **標準画像の場合**:
        - `FileReader.readAsDataURL` を使い、ファイルを直接Data URLとして読み込み、`originalImage.src` に設定する。
    - **`onload` コールバック**: `originalImage.src`への設定後、画像のデコードが完了すると `originalImage.onload` が呼び出される。ここで初めて、キャンバスの寸法を画像に合わせ、`resetApp()` を呼び出してUI全体を初期状態にリセットし、画像をキャンバスに描画する。

3.  **画像処理 (コントラスト調整 `applyThresholdContrast` 関数)**
    - この関数は、ピクセル単位での画像処理を実行する。
    - `ctxBefore.getImageData` を使い、「元画像」キャンバスからピクセルデータを`Uint8ClampedArray`形式で取得する。これは `[R, G, B, A, R, G, B, A, ...]` という1次元配列になっている。
    - スライダーの値（0〜300）を、シグモイド関数 `y = 1 / (1 + exp(-k * (x - 0.5)))` の傾きを決定する係数 `strength` (`k` に相当)に変換する。
    - **ルックアップテーブル (LUT)**: パフォーマンス最適化の要。スライダーが動くたびに、輝度0から255の各入力値に対して、シグモイド関数を適用した結果（出力値）をあらかじめ計算し、長さ256の配列（LUT）に保存する。
    - `for` ループで画像の全ピクセルを巡回処理する。各ピクセルのR, G, Bの各値について、高価な`Math.exp`計算を毎回行うのではなく、先ほど作成したLUTを参照して変換後の値を高速に取得する。
    - 変換後のピクセル配列から新しい `ImageData` オブジェクトを生成し、`ctxAfter.putImageData` を使って「編集後」キャンバスに一括で書き戻す。

4.  **寸法測定ロジック (ウィザードと状態管理)**
    - **ステートマシン**: `measureWizardStep` という変数（`'choice'`, `'calibrating'`, `'measuring'`）を使って、ユーザーが測定ウィザードのどの段階にいるかを管理する、簡易的な有限ステートマシンを実装している。
    - **UI制御 (`setMeasureStep` 関数)**: この関数がUIの司令塔となる。引数で渡されたステップ名に応じて、対応するUIパネル（div）の表示・非表示を切り替え、不要な情報をユーザーから隠す。
    - **`canvasAfter` クリックイベント**: このリスナーの挙動は `measureWizardStep` の現在の値によって変化する。
        - **`'calibrating'` (キャリブレーション中)**: 2回のクリックを待ち受ける。2回目のクリックで、2点間のピクセル距離を計算し、ユーザーが入力した実世界の長さで割ることで、`scale`オブジェクトに「1単位あたりのピクセル数」の比率を保存する。その後、`setMeasureStep('measuring')` を呼び出して自動的に次のステップに移行する。
        - **`'measuring'` (測定中)**: 同じく2回のクリックを待ち受ける。2点間のピクセル距離を計算した後、`scale`オブジェクトに比率が保存されていれば、その比率を使ってピクセル距離を実世界の長さに変換して表示する。保存されていなければ、ピクセル距離をそのまま表示する。

5.  **状態管理 & UI更新 (`resetApp`, `clearImageAndReset`, `switchMode`, `clearMeasurements`)**
    - `resetApp`: アプリケーション全体の状態（コントラストスライダー、測定モード、スケール情報、キャンバス内容）を初期値に戻す包括的な関数。
    - `clearImageAndReset`: `originalImage` を `null` に設定し、`resetApp` を呼び出すことで、読み込まれた画像を完全にクリアする。
    - `switchMode`: 「コントラスト調整モード」と「寸法測定モード」を切り替える際にUIの表示を切り替える。
    - `clearMeasurements`: 現在の測定点や描画をクリアする。

6.  **アプリケーションの終了 (`unload` イベント)**
    - ユーザーがブラウザのタブを閉じるか、ページを離れる直前に `unload` イベントが発火する。
    - このイベントを捕捉し、`navigator.sendBeacon('/shutdown', '')` を実行する。これは、ページが閉じられる間際でも、軽量なHTTPリクエストをサーバーに送信するための信頼性の高い非同期API。
    - このリクエストがバックエンドの `/shutdown` エンドポイントに到達すると、`app.py` は自身のプロセスを終了させ、アプリ全体が閉じる。

---

### 3. パッケージング (`PyInstaller`)

`PyInstaller` を使用して、スタンドアロンの実行可能ファイルを生成する。Pythonインタプリタ、`app.py`、その依存ライブラリ（Flask, Waitress）、およびフロントエンドのアセット群（`static`と`templates`フォルダ）をすべて単一の`.exe`ファイルにバンドルする。

---
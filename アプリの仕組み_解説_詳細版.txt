# アプリケーションの仕組み解説 - 詳細版

## 1. 概要

このアプリケーションは、デスクトップ上で動作するスタンドアロンの「画像解析ツール」です。
ユーザーが画像ファイルを読み込み、コントラスト調整、鮮明化、寸法測定、粒径測定といった高度な解析タスクを、専門的なソフトウェアをインストールすることなく、直感的なUIで実行できることを目的としています。

Web技術（HTML, JavaScript, CSS）をUIの基盤としながらも、Pythonサーバーと実行ファイル化技術を組み合わせることで、ダブルクリックだけで起動できる手軽なデスクトップアプリケーションとしての体験を提供します。

---

## 2. 主要機能の詳細

### 2.1. 画像の読み込みと表示
- **操作:** 「画像を選択」ボタンから画像ファイル（PNG, JPGなど）を読み込みます。
- **仕組み:** 読み込まれた画像は、画面左側の「元画像 (Before)」キャンバスと、編集対象となる右側の「編集後 (After)」キャンバスの両方に描画されます。これにより、ユーザーは編集結果を元の画像とリアルタイムで比較できます。

### 2.2. コントラスト調整
- **操作:** 「コントラスト調整」モードを選択し、スライダーを動かして画像のコントラストを変更します。
- **仕組み:**
    - スライダーの値（0%〜300%）に基づいて、画像のルックアップテーブル（LUT）を動的に生成します。
    - このLUTは、画像の各ピクセルの明るさを、シグモイド曲線に似たカーブに沿って変換します。値が100%未満ならコントラストが低く、100%を超えると高くなります。
    - この変換処理は、後述する**画像処理パイプライン**の一部として、他のモードに切り替えても維持されます。

### 2.3. 画像鮮明化
- **操作:** 「画像鮮明化」モードを選択し、スライダーを動かして画像の鮮明度を調整します。
- **仕組み:**
    - **畳み込み演算 (Convolution):** 画像処理における「畳み込み演算」という手法を用いて、エッジ（輪郭）を強調します。
    - **鮮明化カーネル:** `[[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]` という3x3の行列（カーネル）を画像の各ピクセルに適用します。これは、中心ピクセルの値を9倍し、周囲8ピクセルの値を引く計算です。結果として、ピクセルの値が周囲と大きく異なる「エッジ部分」が強調され、画像がシャープになります。
    - スライダーの値は、この鮮明化処理を適用した画像と元の画像とをどの割合で混ぜ合わせるかを決定し、効果の強度を調整します。
    - この処理も**画像処理パイプライン**に組み込まれており、効果は全モードで持続します。

### 2.4. 寸法測定
- **操作:**
    1.  「寸法測定」モードを選択します。
    2.  画像上の既知の長さ（例: スケールバー）の実際の長さと単位を入力します。
    3.  「スケール設定開始」ボタンを押し、画像上で既知の長さに対応する2点をクリックしてスケールをキャリブレーションします。
    4.  「測定を開始する」ボタンを押し、測定したい対象の2点をクリックすると、実際の長さが表示されます。
- **仕組み:**
    - 2点間のピクセル距離と、ユーザーが入力した実際の長さを関連付け、「1ピクセルあたりの実世界の長さ」を算出します。
    - 以降の測定では、クリックされた2点間のピクセル距離にこのスケール値を乗算することで、実世界の長さを計算・表示します。

### 2.5. 粒径測定
- **操作:**
    1.  「粒径測定」モードを選択します。
    2.  「二値化閾値」スライダーを調整し、測定したい粒子が白く、背景が黒くなるようにします。
    3.  寸法測定と同様に、スケール設定を行います。
    4.  「粒径を測定する」ボタンを押し、分析したい領域を2点のクリックで指定するか、「粒径を複数測定する」ボタンで画像全体の粒子を自動検出・測定します。
- **仕組み:**
    - **二値化:** まず、画像全体が「コントラスト」「鮮明化」の適用後の状態で、指定された閾値に基づいて白黒の二値画像に変換されます。
    - **粒子検出 (Flood Fill):** 二値化された画像に対し、連結している白いピクセルの塊を一つの「粒子」として検出します。このアルゴリズムは「Flood Fill（塗りつぶし）」を応用したものです。
    - **フィルタリング:** 検出された粒子のうち、小さすぎるもの（ノイズ）や、アスペクト比（縦横比）が`1.5`を超える細長い形状のものは、測定対象から除外されます。
    - **結果算出:** フィルタリングを通過した粒子の数、平均直径（ピクセル単位）、およびスケール設定に基づいた実世界単位での平均直径が計算され、画面に表示されます。

---

## 3. 技術的な仕組み

### 3.1. 基本構成
- **バックエンド (Backend):** Python + Flask + Waitress
  - 主にアプリケーションの起動、HTML/CSS/JSファイルの配信、ブラウザの自動起動といった「ガワ」の役割を担います。
- **フロントエンド (Frontend):** HTML + CSS (Bootstrap) + JavaScript
  - UIの構築、ユーザー操作への応答、そしてCanvas APIを利用した画像処理ロジックのすべてを担当します。アプリケーションの「頭脳」と「体」に相当する部分です。

### 3.2. フロントエンドの詳細
#### 画像処理パイプライン
このアプリケーションの心臓部です。ユーザーの操作（モード切替やスライダー操作）があるたびに、`redrawAfterCanvas`関数が呼び出され、以下の処理が連鎖的に実行されます。

1.  **元画像の取得:** `Before`キャンバスから元の画像データを取得します。
2.  **コントラスト適用:** `applyThresholdContrast`関数が、取得した画像データに現在のスライダー値に基づいたコントラスト調整を適用し、新しい画像データを返します。
3.  **鮮明化適用:** `applySharpening`関数が、コントラスト調整後の画像データに、現在の鮮明化スライダーの値に基づいた畳み込み演算を適用し、さらに新しい画像データを返します。
4.  **ベース画像描画:** 上記の処理で完成した「加工後の画像データ」を`After`キャンバスに描画します。

このパイプライン構造により、「コントラスト」と「鮮明化」の効果は、どのモードにいても常にベースとして適用され続けることになります。

#### モード別処理
ベース画像が描画された後、現在のモードに応じて以下の追加処理が行われます。

- **`particle_size`モードの場合:**
  - `applyThreshold`関数が呼び出されます。この関数は、`After`キャンバスの現在の内容（＝加工後の画像）を取得し、それをグレースケール変換した上で、二値化スライダーの値で白黒画像に変換し、再度`After`キャンバスに描き込みます。
  - その後、検出済みの粒子があれば、その輪郭が緑色の四角形で上描きされます。
- **`measure`モードの場合:**
  - `After`キャンバスの加工後画像の上に、スケール設定や測定のためにクリックされた点（マーカー）や線が上描きされます。

### 3.3. バックエンドの役割
このアプリケーションでは、画像処理の計算はすべてフロントエンド（ブラウザ上のJavaScript）で行われるため、バックエンド（Python）の役割は非常にシンプルです。

- **ファイル配信:** Flaskフレームワークを使い、アプリケーションの骨格である`index.html`や、見た目を定義する`style.css`、そして全てのロジックを担う`script.js`をブラウザに提供します。
- **サーバー実行:** `waitress`ライブラリをWebサーバーとして利用し、Flaskアプリケーションを安定して動作させます。
- **ブラウザ自動起動:** `webbrowser`ライブラリを使い、アプリケーション起動時に自動でユーザーのデフォルトブラウザを開き、`http://127.0.0.1:8080`にアクセスさせます。これにより、ユーザーはサーバーの存在を意識する必要がありません。

---

## 4. 実行ファイル化の仕組み

このアプリケーションが単一の`.exe`ファイルとして動作する仕組みは、`PyInstaller`というツールによって実現されています。

- **全てを同梱:** `PyInstaller`は、`app.py`スクリプトだけでなく、その実行に必要なPythonの実行環境、FlaskやWaitressといったライブラリ、さらには`templates`や`static`フォルダ内のHTML/CSS/JSファイルまで、すべてを単一の`.exe`ファイル内に圧縮して同梱します。
- **実行時の自己展開:** `.exe`ファイルが実行されると、まずPCの一時フォルダに内包しているファイル群をすべて展開します。
- **パスの動的解決:** `app.py`内のコードが、自分が`.exe`として実行されたことを検知し、HTMLなどのファイルの置き場所として、この一時フォルダを指すように動的にパスを解決します。

この仕組みにより、PythonがインストールされていないPCでも、依存関係を気にすることなく、ダブルクリックだけでアプリケーションを起動・利用することが可能になっています。

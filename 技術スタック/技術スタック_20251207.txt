# 技術スタック・修正内容の解説 (2025/12/07)

このドキュメントは、今回実施したアプリケーションの修正と、Dockerを使ってローカル環境でアプリケーションを動作させる仕組みについて詳しく解説するものです。

## 1. なぜDockerでローカルアプリがブラウザで動くのか？

これが今回の一番の核心です。ローカルで開発したアプリケーションが、Dockerを介して、まるでサーバーにデプロイされたかのようにブラウザで動く仕組みを解説します。

### a. Dockerとは「アプリケーション専用の小さなPC」を作る技術

PC上でWordやExcelを動かすように、Dockerは「コンテナ」と呼ばれる、アプリケーションを動かすためだけの隔離された仮想的な環境を作ります。このコンテナは、それ自体がOS（多くはLinux）や必要なライブラリ、設定ファイルなどを含んだ、自己完結した「小さなPC」のようなものです。

### b. Dockerfile：コンテナの「設計図」

では、その「小さなPC」に何を入れるかは、`Dockerfile` という設計図に記述します。今回の `Dockerfile` の内容を翻訳すると、以下のようになります。

- **`FROM python:3.9-slim`**:
  「Python 3.9 がインストールされた、軽量なLinux OSを土台にしてください」
- **`WORKDIR /app`**:
  「コンテナの中に `/app` という作業フォルダを作ってください」
- **`COPY requirements.txt .` と `RUN pip install ...`**:
  「まず `requirements.txt` を作業フォルダにコピーし、そこに書かれているライブラリ（Flask, Gunicorn, SQLAlchemyなど）を `pip install` してください」
- **`COPY . .`**:
  「ローカルにある `app.py` や `templates` フォルダ、`static` フォルダなど、すべてのファイルを丸ごと作業フォルダにコピーしてください」
- **`CMD ["gunicorn", ...]`**:
  「このコンテナが起動したら、`gunicorn` というWebサーバーを使って、`app.py` の中の `app` という名前のFlaskアプリケーションを実行してください」

### c. イメージ化とコンテナ実行

- **`docker build`**: 上記の `Dockerfile` (設計図) を元に、いつでも同じコンテナを再現できる「イメージ」というテンプレートを作成します。
- **`docker run`**: 作成した「イメージ」から、実際に動作する「コンテナ」を起動します。

### d. ポートフォワーディング：ローカルとコンテナを繋ぐ「橋」

ここが最も重要なポイントです。`docker run` コマンドに付けた `-p 8080:8080` というオプションが、ローカルPCとコンテナの間の「橋渡し」をします。

- **意味**: 「**ローカルPC（ホスト）の8080番ポート**に来た通信を、**コンテナ内の8080番ポート**に転送（フォワーディング）してください」という設定です。

この設定により、以下のような流れが実現します。

1.  **あなた**: ローカルPCのブラウザで `http://localhost:8080` を開く。
2.  **ローカルPC**: 「自分自身（localhost）の8080番ポート」宛のアクセスだと認識する。
3.  **Docker**: `-p 8080:8080` の設定に基づき、このアクセスを横取りして、コンテナ内の8080番ポートにそのまま転送する。
4.  **コンテナ**: Gunicornサーバーが8080番ポートで待ち受けているため、リクエストを受け取り、Flaskアプリケーション (`app.py`) に渡す。
5.  **Flaskアプリ**: リクエストを処理し、HTMLなどのレスポンスを返す。
6.  レスポンスは逆のルートを辿り、Dockerを経由してローカルPCのブラウザに表示される。

この仕組みにより、ローカルPCのブラウザからは、まるでローカルPC上で直接サーバーが動いているかのように見えますが、実際にはDockerコンテナという隔離された環境でアプリケーションが動作しているのです。

### e. Docker Desktopの役割

Docker Desktopは、これらDockerの複雑な仕組み（Dockerエンジンの管理、ネットワーク設定、コンテナの起動/停止など）を、Windows上で簡単に使えるようにしてくれるソフトウェアです。

---

## 2. 最終的なエラー「no such table」の原因と解決策

最後に解決したデータベースのエラーについて解説します。

- **現象**: アプリケーションは開けるが、画像を保存しようとするとエラーになる。
- **エラーログ**: `sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: original_image`
- **原因**: データベース内に `original_image` をはじめとするテーブルが作成されていませんでした。`app.py` の中でテーブルを作成する命令 `db.create_all()` が、データベースのモデル（設計情報）を読み込む前に呼び出されていたため、Gunicorn経由で起動した際にテーブル作成が失敗していました。
- **解決策**: `app.py` を修正し、`db.create_all()` の呼び出しを、全てのデータベースモデルクラスが定義された**後**に移動しました。これにより、アプリケーションが起動する際に、必ず正しい順序でテーブルが作成されるようになり、問題が解決しました。

---

## 3. これまでのトラブルシューティングのまとめ

1.  **Dockerコマンドのエラー**: `docker build` 時に「Dockerデーモンに接続できない」というエラーが発生。
    - **原因**: Docker Desktopが起動していなかった。
    - **解決**: Docker Desktopを起動することで解決。

2.  **サーバーログにエラーが出ない**: ブラウザではエラーに見えるのに、ターミナルに何もログが出力されない問題。
    - **原因**: `app.py` の `try...except` ブロックがエラーを捕捉するだけでログに出力していなかった。
    - **解決**: `app.py` に `logging` を追加し、エラーを明示的にログ出力するように修正。これにより、次の根本原因が判明した。

3.  **データベースのテーブルが存在しない**: 上記のログ出力によって `no such table` エラーが判明。
    - **原因**: `db.create_all()` の実行タイミングの問題。
    - **解決**: `app.py` 内の `db.create_all()` の位置を修正し、イメージを再ビルドすることで解決。

 1. Webフレームワーク (例: Flask, Django)
   - 役割: アプリケーションの 「骨格やロジック」 を作るための道具。
   - 料理の例え: レシピ本や調理器具セット
   - 開発者はこれを使って、Webサイトの「どのURLにアクセスされたら、何をして、どんなページを表示するか
     」といった具体的な処理（ロジック）をPythonで記述します。
       - Flask:
           - マイクロフレームワーク と呼ばれます。
           - 例えるなら「シンプルなDIYキット」。最小限の機能（URLのルーティングなど）だけを提供し、デ
             ータベース接続などの追加機能は、開発者が必要なライブラリを自分で選んで組み合わせていきま
             す。
           - 特徴:
             軽量で自由度が高い。小〜中規模のアプリケーションやAPIサーバーの構築に素早く着手できます。
       - Django:
           - フルスタックフレームワーク と呼ばれます。
           - 例えるなら「全部入りのシステムキッチン」。Webサイト開発に必要な機能（ユーザー認証、管理画
             面、データベース操作機能(ORM)など）が最初からすべて揃っています。
           - 特徴: 「バッテリー同梱（Batteries
             Included）」が哲学。大規模で複雑なアプリケーションを迅速かつ体系的に開発するのに向いてい
             ますが、その分ルールが多く学習コストは高めです。

  2. WSGI (Web Server Gateway Interface)
   - 役割: Webサーバー (Gunicorn) と Webフレームワーク (Flask/Django) を繋ぐ
     「通訳」または「共通規格」。
   - 料理の例え: 店員と厨房の間の「注文票の書き方ルール」
   - これがあるおかげで、Gunicornは相手がFlaskだろうとDjangoだろうと、同じ方法でコミュニケーションでき
     ます。開発者は普段これを直接意識する必要はほとんどありません。

  3. Webサーバー / WSGIサーバー (例: Gunicorn)
   - 役割: 作成したアプリケーションを、インターネットからの多数のリクエストを受け付けられるようにする
     「受付係」。
   - 料理の例え: レストランの「ホールスタッフ」
   - FlaskやDjangoに組み込まれている開発用サーバー (app.run())
     は、あくまで開発中のテスト用で、一度に一つのリクエストしか処理できません。
   - Gunicornのような本番用のWebサーバーは、複数のリクエストを同時に効率よく捌いたり、サーバーが落ちて
     も自動で再起動したりと、安定してサービスを運用するための多くの機能を備えています。

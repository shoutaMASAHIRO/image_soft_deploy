■ Webアプリケーションの構築

- Flask
  - 役割: Webフレームワーク
  - 理由: PythonでWebアプリケーション（サーバー）を簡単に構築するために使用します。ユーザーのブラウザからのリクエスト（画像のアップロードなど）を受け取り、処理結果（HTML画面や画像データ）を返す役割を担います。このシステムの「骨格」となる部分です。
　【メリット】
  - 最小構成がかなり小さいから、**「とりあえず動くAPIサーバー」**をすぐ書ける。
  - Pythonの既存コードをそのまま活かしやすい
  - 軽量で余計なものが少ない（Flaskはマイクロフレームワークなので、「必須のWeb機能＋ちょっとした便利機能」くらいしか持ってない。）

■ 画像処理とデータ変換

- opencv-python-headless
  - 役割: コンピュータビジョンライブラリ
  - 理由: 画像の読み込み、変換、保存といった中心的な処理に使用しています。具体的には、アップロードされたファイルデータを画像形式に変換し、ディープラーニングモデルが扱える形式に整え、最後に処理後のデータを再び画像ファイルとして書き出すために利用しています。`headless`版は、GUI（画面表示）機能を含まないサーバー向けのバージョンであり、今回のシステムに最適です。

- Pillow
  - 役割: 画像処理ライブラリ
  - 理由: Pythonで画像を扱う際の標準的なライブラリです。FlaskやOpenCVの内部で画像データを扱う際に補助的に利用されることがあるため、画像処理プロジェクトの基本的なライブラリとして含めています。

■ ディープラーニングモデルの利用

- torch & torchvision
  - 役割: ディープラーニングフレームワーク
  - 理由: 「学習済みモデルを使いたい」というご要望にお応えするために追加しました。
    - `torch`: DnCNNのようなニューラルネットワークの構築と実行を可能にするPyTorchのコアライブラリです。画像のノイズ除去を行うモデルの計算処理そのものを担当します。
    - `torchvision`: PyTorchで画像処理タスクを行うための補助ライブラリです。今回は直接使用していませんが、PyTorchで画像を扱う際にはほぼ必須のライブラリとなります。

# 画像解析ツールの技術スタックと実行ファイル化の解説

## 概要

このアプリケーションは、元々は「PythonのWebサーバーをターミナルで起動し、ユーザーが手動でWebブラウザで指定URLにアクセスする」という形式でした。

これを、「ユーザーがダブルクリックするだけで起動し、自動でブラウザが立ち上がる」というスタンドアロンのデスクトップアプリケーション形式に変換しました。これにより、PythonがインストールされていないPCでも動作し、専門知識がない人でも簡単に利用できるようになりました。

以下に、それを実現した主要な技術と仕組みを解説します。

---

## 主要技術スタック

- **Python**: アプリケーションの基本言語。
- **Flask**: Webアプリケーションの骨格を作るためのフレームワーク。画面表示（HTML）と内部ロジックを連携させます。
- **Waitress**: Python製のWSGIサーバー。開発用の簡易サーバーではなく、より安定した本番環境グレードのサーバーとして利用しました。
- **PyInstaller**: Pythonスクリプトとそれに関連する全てのファイル（ライブラリ、HTML、CSS等）を、単一の実行可能ファイル（`.exe`）にパッケージングするためのツール。今回の「実行ファイル化」の最重要技術です。

---

## 実行ファイル化の仕組み (なぜ`.exe`だけで動くのか？)

### 1. `PyInstaller`によるパッケージング

`app.exe`が自己完結して動作する最大の理由は、`PyInstaller`がアプリケーションの実行に必要な**全ての部品をファイル内部に梱包（パッケージング）している**からです。

- **Python実行環境の同梱**: 実行先のPCにPythonがインストールされていなくても動くように、`app.exe`内には小規模なPython実行環境（インタプリタ）そのものが含まれています。
- **ライブラリの同梱**: `pip`でインストールした`Flask`や`Waitress`などのライブラリも全て`app.exe`内に取り込まれます。
- **静的ファイル（HTML/CSS/JS）の同梱**: アプリケーションの見た目や動きを定義する`templates`フォルダ（HTMLファイル）と`static`フォルダ（CSS, JSファイル）も、`pyinstaller`コマンド実行時に`--add-data`オプションで指定することで、`app.exe`内に含めました。

これにより、`app.exe`は外部のファイルに一切依存しない、自己完結したプログラムとなります。

### 2. 実行時のファイル展開とパス解決

`app.exe`をダブルクリックすると、内部では以下のことが起きています。

1.  **一時フォルダへの展開**: `app.exe`は、PCの一時フォルダ（Temp）に、自身が内包しているPython実行環境、ライブラリ、HTML/CSSファイルなどを一時的に展開します。この一時フォルダの場所は`_MEIPASS`という特殊な変数で知ることができます。
2.  **パスの動的解決**: 修正後の`app.py`には、自分が実行ファイルとして起動されたのか、通常のPythonスクリプトとして起動されたのかを判別するロジックを追加しました。
    ```python
    if getattr(sys, 'frozen', False):
        # 実行ファイルとして起動された場合
        base_dir = sys._MEIPASS
        # HTML/CSSファイルの場所を一時フォルダ内に指定
        template_folder = os.path.join(base_dir, 'templates')
        static_folder = os.path.join(base_dir, 'static')
        app = Flask(__name__, template_folder=template_folder, static_folder=static_folder)
    else:
        # 通常のスクリプトとして起動された場合
        app = Flask(__name__)
    ```
    このコードにより、実行ファイルは**どこに置かれても**、自分自身が展開した一時フォルダの中から正しくHTMLやCSSファイルを見つけ出すことができます。これが、`app.exe`をデスクトップなど好きな場所に移動させても動作する理由です。

### 3. Webサーバーの内蔵とブラウザの自動起動

- **サーバーの役割**: `app.exe`は、内部で`Waitress`というWebサーバーを起動します。これは表には見えませんが、バックグラウンドで動いており、ブラウザからのアクセスを待ち受けています。
- **自動化によるUX向上**: アプリケーションが起動すると、Pythonの`webbrowser`ライブラリが呼び出され、自動的にデフォルトのWebブラウザが立ち上がり、`http://127.0.0.1:8080`にアクセスします。これにより、ユーザーは「`.exe`をダブルクリックする」という操作だけで、すぐにアプリケーションを使い始めることができます。

---

## 結論

`PyInstaller`がPython実行環境と全依存ファイルを単一ファイルにまとめ、修正された`app.py`が実行時のファイルパスを賢く解決することで、**Web技術を使いながらも、見た目や使い勝手は完全にスタンドアロンのデスクトップアプリケーション**として振る舞うことが可能になりました。これが、`app.exe`ファイル一つで、どのPCでも手軽にアプリケーションを起動できる仕組みの全体像です。

---
### 画像鮮明化機能

**概要:**
ユーザーがアップロードした画像の鮮明度を調整する機能を追加しました。

**技術詳細:**
- **畳み込み演算 (Convolution):**
  - この機能は、画像処理における基本的な手法である「畳み込み演算」を用いて実装されています。
  - 具体的には、3x3の「鮮明化カーネル」という行列を画像の各ピクセルに適用しています。
  - 使用したカーネルは `[[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]` です。これは、中心ピクセルの値を強調し、周囲のピクセルとの差を大きくすることでエッジを際立たせ、画像をシャープに見せる効果があります。
- **実装:**
  - この処理は、外部ライブラリに依存せず、ブラウザ標準のCanvas APIとJavaScriptのみで実装されています。
  - `canvas.getContext('2d').getImageData()` でピクセルデータを取得し、ピクセル単位で上記の畳み込み演算を適用後、`putImageData()` でキャンバスに再描画しています。

---
### モード切替時のエフェクト（コントラスト・鮮明化）の持続

**概要:**
「コントラスト調整」および「画像鮮明化」モードで調整した画像の見た目が、他のモード（寸法測定、粒径測定）に切り替えた後も維持されるように修正しました。

**技術詳細:**
- **画像処理パイプラインの構築:**
  - これを実現するために、描画ロジック (`redrawAfterCanvas` 関数) をリファクタリングし、一連の画像処理パイプラインを構築しました。
  - 従来は各モードが独立して描画を行っていましたが、新しいロジックでは以下の順で処理が連鎖的に実行されます。
    1. 元の画像を読み込む。
    2. コントラスト調整を適用する。
    3. その結果に対し、画像鮮明化を適用する。
    4. 処理済みの画像を「編集後」キャンバスに描画する。
    5. 現在のモードに応じた追加の描画（測定線や粒子の輪郭など）を、その上に重ねて描画する。
- **実装:**
  - 各画像処理関数 (`applyThresholdContrast`, `applySharpening`) が、入力として`ImageData`オブジェクトを受け取り、処理後の新しい`ImageData`オブジェクトを返すように修正しました。
  - これにより、各処理を柔軟に組み合わせ、一貫した見た目をすべてのモードで実現しています。


補足
フロントエンド

  - ユーザーが触る画面部分（HTML/CSS/JavaScript、React など、ブラウザ上で動くプログラムのこと）

バックエンド

  - ログイン処理、データ保存（今回はSQLite3）、計算などをするサーバー側のプログラム（Ruby, Ruby on Rails, Node.js など）主要言語＋フレームワークで動かすことが多い（今回は   
    Python+flask）

サーバー

  - バックエンドが動いているコンピュータ（たとえば AWS の EC2）

ブラウザ

  - Webアプリを表示＆操作するためのソフト（Chrome 等）

これらが合わさって動いている「サービス全体」を、Webアプリケーションと呼ぶイメージです。



🐍 Python

メリット
文法がシンプルで読みやすく、保守しやすい
データ処理・機械学習・科学技術（NumPy, pandas, PyTorch etc.）のライブラリが超豊富
Web（Flask/Django）、スクリプト、自動化、CLIツールなど用途が広い

デメリット
処理速度はC系・Rust・Goなどに比べると遅め
マルチスレッドでCPUをフルに使うのが苦手（GILの制約）
モバイルネイティブアプリやブラウザ内実行には向かない

✅ Ruby のメリット（3つ）

書いてて気持ちいい・読みやすい
自然言語っぽく書けて、「何をしたいコードなのか」が直感で分かりやすい。

Ruby on Rails でWebサービスを爆速開発できる
認証・CRUD・ルーティングなどが揃っていて、0→1開発の生産性が高い。

オブジェクト指向が徹底されていて設計しやすい
すべてがオブジェクトで統一されており、きれいな設計・メソッドチェーンを書きやすい。

❌ Ruby のデメリット（3つ）

パフォーマンスはそれほど高くない
重い数値計算や高スループットが必要な処理にはあまり向かない。

Web以外の分野でエコシステムが弱め
データ解析・機械学習・画像処理などは Python に大きく劣る。

実務がRails前提になりがちで、学習コストもかかる
Ruby = Rails になりやすく、フレームワークのお作法を覚える必要がある。

🌐 JavaScript

メリット
ブラウザで唯一ネイティブに動く言語 → どのPCでもインストール不要で使える
UI・インタラクション（クリック、ドラッグ、アニメーション）が得意
Node.js を使えばフロント・バックエンドどちらも JS で統一できる

デメリット
歴史的な仕様のクセが多く、言語としては一貫性に欠ける部分もある
大規模化すると設計をちゃんとしないとコードがカオスになりやすい
フレームワークやライブラリの流行が変わりやすく追従が大変

🧱 Flask

メリット
コアが小さく、最小コードでWebサーバーを立てられる（学びやすい）
余計な機能が付いていないので、設計の自由度が高い
既存の Python スクリプト（画像解析・計算など）を Web API 化しやすい

デメリット
認証・管理画面・ORMなどを自分で選んで組む必要があり、設計力が求められる
プロジェクトが大きくなると「構成のベストプラクティス」を自分で決める必要がある
大規模サービス向けの機能は Django に比べて「自前実装」になりがち

🏢 Django

メリット
認証・ORM・管理画面・フォームなど Webサービスに必要な機能が一式揃っている
プロジェクト構成や書き方の型が決まっていて、チーム開発に向いている
ユーザー登録型の中〜大規模Webサービスを素早く作りやすい

デメリット
覚える概念やファイル（models/views/urls/forms…）が多く、最初は重い
小さいツールや簡単なAPIにはオーバースペックになりやすい
Django流のやり方に乗らない高度なカスタムをしようとすると大工事になりがち

🧬 SQLAlchemy

メリット
Python 用の強力な ORM／クエリビルダーで、DB操作をオブジェクトとして扱える
SQLite, PostgreSQL, MySQL など複数のDBを、同じコードに近い形で扱える
生SQLも書けるし、ORMも使えるハイブリッドな使い方が可能

デメリット
学習コストがやや高め（セッション、マッピング、リレーションなど概念が多い）
単純な CRUD だけなら素の SQL の方がわかりやすいケースもある
ORMのクセを理解しないと、無駄なクエリやパフォーマンス問題を起こしやすい


【デプロイする過程での難しさ】
ローカルと本番環境の違いを吸収すること
ローカルは「PyInstallerでexe＋Waitress＋SQLite」、本番は「Gunicorn＋PostgreSQL＋クラウド（Render / Docker）」という構成の違いがあった。
同じアプリなのに、起動方法・ポート・ファイルパス・ログの出方が全部違うので、それぞれの環境でどう動いているかを頭の中で整理するのが大変だった。
SQLite から PostgreSQL への切り替え（SQLAlchemyの理解）
ローカルでは気にせず動いていたDB処理が、クラウドでPostgreSQLに変わった途端に接続文字列・マイグレーション・db.create_all() のタイミングなどで何度もエラーになった。
SQLAlchemy をちゃんと使って「どの環境でも同じコードで動くようにする」設計に直すところが、実装だけでなく理解面でも難しかった。
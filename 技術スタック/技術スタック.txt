プロジェクトライブラリの選定理由

このプロジェクトで使用されている主要なPythonライブラリとその選定理由です。

■ Webアプリケーションの構築

- Flask
  - 役割: Webフレームワーク
  - 理由: PythonでWebアプリケーション（サーバー）を簡単に構築するために使用します。ユーザーのブラウザからのリクエスト（画像のアップロードなど）を受け取り、処理結果（HTML画面や画像データ）を返す役割を担います。このシステムの「骨格」となる部分です。

■ 画像処理とデータ変換

- opencv-python-headless
  - 役割: コンピュータビジョンライブラリ
  - 理由: 画像の読み込み、変換、保存といった中心的な処理に使用しています。具体的には、アップロードされたファイルデータを画像形式に変換し、ディープラーニングモデルが扱える形式に整え、最後に処理後のデータを再び画像ファイルとして書き出すために利用しています。`headless`版は、GUI（画面表示）機能を含まないサーバー向けのバージョンであり、今回のシステムに最適です。

- Pillow
  - 役割: 画像処理ライブラリ
  - 理由: Pythonで画像を扱う際の標準的なライブラリです。FlaskやOpenCVの内部で画像データを扱う際に補助的に利用されることがあるため、画像処理プロジェクトの基本的なライブラリとして含めています。

■ ディープラーニングモデルの利用

- torch & torchvision
  - 役割: ディープラーニングフレームワーク
  - 理由: 「学習済みモデルを使いたい」というご要望にお応えするために追加しました。
    - `torch`: DnCNNのようなニューラルネットワークの構築と実行を可能にするPyTorchのコアライブラリです。画像のノイズ除去を行うモデルの計算処理そのものを担当します。
    - `torchvision`: PyTorchで画像処理タスクを行うための補助ライブラリです。今回は直接使用していませんが、PyTorchで画像を扱う際にはほぼ必須のライブラリとなります。

# 画像解析ツールの技術スタックと実行ファイル化の解説

## 概要

このアプリケーションは、元々は「PythonのWebサーバーをターミナルで起動し、ユーザーが手動でWebブラウザで指定URLにアクセスする」という形式でした。

これを、「ユーザーがダブルクリックするだけで起動し、自動でブラウザが立ち上がる」というスタンドアロンのデスクトップアプリケーション形式に変換しました。これにより、PythonがインストールされていないPCでも動作し、専門知識がない人でも簡単に利用できるようになりました。

以下に、それを実現した主要な技術と仕組みを解説します。

---

## 主要技術スタック

- **Python**: アプリケーションの基本言語。
- **Flask**: Webアプリケーションの骨格を作るためのフレームワーク。画面表示（HTML）と内部ロジックを連携させます。
- **Waitress**: Python製のWSGIサーバー。開発用の簡易サーバーではなく、より安定した本番環境グレードのサーバーとして利用しました。
- **PyInstaller**: Pythonスクリプトとそれに関連する全てのファイル（ライブラリ、HTML、CSS等）を、単一の実行可能ファイル（`.exe`）にパッケージングするためのツール。今回の「実行ファイル化」の最重要技術です。

---

## 実行ファイル化の仕組み (なぜ`.exe`だけで動くのか？)

### 1. `PyInstaller`によるパッケージング

`app.exe`が自己完結して動作する最大の理由は、`PyInstaller`がアプリケーションの実行に必要な**全ての部品をファイル内部に梱包（パッケージング）している**からです。

- **Python実行環境の同梱**: 実行先のPCにPythonがインストールされていなくても動くように、`app.exe`内には小規模なPython実行環境（インタプリタ）そのものが含まれています。
- **ライブラリの同梱**: `pip`でインストールした`Flask`や`Waitress`などのライブラリも全て`app.exe`内に取り込まれます。
- **静的ファイル（HTML/CSS/JS）の同梱**: アプリケーションの見た目や動きを定義する`templates`フォルダ（HTMLファイル）と`static`フォルダ（CSS, JSファイル）も、`pyinstaller`コマンド実行時に`--add-data`オプションで指定することで、`app.exe`内に含めました。

これにより、`app.exe`は外部のファイルに一切依存しない、自己完結したプログラムとなります。

### 2. 実行時のファイル展開とパス解決

`app.exe`をダブルクリックすると、内部では以下のことが起きています。

1.  **一時フォルダへの展開**: `app.exe`は、PCの一時フォルダ（Temp）に、自身が内包しているPython実行環境、ライブラリ、HTML/CSSファイルなどを一時的に展開します。この一時フォルダの場所は`_MEIPASS`という特殊な変数で知ることができます。
2.  **パスの動的解決**: 修正後の`app.py`には、自分が実行ファイルとして起動されたのか、通常のPythonスクリプトとして起動されたのかを判別するロジックを追加しました。
    ```python
    if getattr(sys, 'frozen', False):
        # 実行ファイルとして起動された場合
        base_dir = sys._MEIPASS
        # HTML/CSSファイルの場所を一時フォルダ内に指定
        template_folder = os.path.join(base_dir, 'templates')
        static_folder = os.path.join(base_dir, 'static')
        app = Flask(__name__, template_folder=template_folder, static_folder=static_folder)
    else:
        # 通常のスクリプトとして起動された場合
        app = Flask(__name__)
    ```
    このコードにより、実行ファイルは**どこに置かれても**、自分自身が展開した一時フォルダの中から正しくHTMLやCSSファイルを見つけ出すことができます。これが、`app.exe`をデスクトップなど好きな場所に移動させても動作する理由です。

### 3. Webサーバーの内蔵とブラウザの自動起動

- **サーバーの役割**: `app.exe`は、内部で`Waitress`というWebサーバーを起動します。これは表には見えませんが、バックグラウンドで動いており、ブラウザからのアクセスを待ち受けています。
- **自動化によるUX向上**: アプリケーションが起動すると、Pythonの`webbrowser`ライブラリが呼び出され、自動的にデフォルトのWebブラウザが立ち上がり、`http://127.0.0.1:8080`にアクセスします。これにより、ユーザーは「`.exe`をダブルクリックする」という操作だけで、すぐにアプリケーションを使い始めることができます。

---

## 結論

`PyInstaller`がPython実行環境と全依存ファイルを単一ファイルにまとめ、修正された`app.py`が実行時のファイルパスを賢く解決することで、**Web技術を使いながらも、見た目や使い勝手は完全にスタンドアロンのデスクトップアプリケーション**として振る舞うことが可能になりました。これが、`app.exe`ファイル一つで、どのPCでも手軽にアプリケーションを起動できる仕組みの全体像です。

---
### 画像鮮明化機能

**概要:**
ユーザーがアップロードした画像の鮮明度を調整する機能を追加しました。

**技術詳細:**
- **畳み込み演算 (Convolution):**
  - この機能は、画像処理における基本的な手法である「畳み込み演算」を用いて実装されています。
  - 具体的には、3x3の「鮮明化カーネル」という行列を画像の各ピクセルに適用しています。
  - 使用したカーネルは `[[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]` です。これは、中心ピクセルの値を強調し、周囲のピクセルとの差を大きくすることでエッジを際立たせ、画像をシャープに見せる効果があります。
- **実装:**
  - この処理は、外部ライブラリに依存せず、ブラウザ標準のCanvas APIとJavaScriptのみで実装されています。
  - `canvas.getContext('2d').getImageData()` でピクセルデータを取得し、ピクセル単位で上記の畳み込み演算を適用後、`putImageData()` でキャンバスに再描画しています。

---
### モード切替時のエフェクト（コントラスト・鮮明化）の持続

**概要:**
「コントラスト調整」および「画像鮮明化」モードで調整した画像の見た目が、他のモード（寸法測定、粒径測定）に切り替えた後も維持されるように修正しました。

**技術詳細:**
- **画像処理パイプラインの構築:**
  - これを実現するために、描画ロジック (`redrawAfterCanvas` 関数) をリファクタリングし、一連の画像処理パイプラインを構築しました。
  - 従来は各モードが独立して描画を行っていましたが、新しいロジックでは以下の順で処理が連鎖的に実行されます。
    1. 元の画像を読み込む。
    2. コントラスト調整を適用する。
    3. その結果に対し、画像鮮明化を適用する。
    4. 処理済みの画像を「編集後」キャンバスに描画する。
    5. 現在のモードに応じた追加の描画（測定線や粒子の輪郭など）を、その上に重ねて描画する。
- **実装:**
  - 各画像処理関数 (`applyThresholdContrast`, `applySharpening`) が、入力として`ImageData`オブジェクトを受け取り、処理後の新しい`ImageData`オブジェクトを返すように修正しました。
  - これにより、各処理を柔軟に組み合わせ、一貫した見た目をすべてのモードで実現しています。


補足
フロントエンド

ユーザーが触る画面部分（HTML/CSS/JavaScript、React など）

バックエンド

ログイン処理、データ保存、計算などをするサーバー側のプログラム（Rails, Node.js など）

サーバー

バックエンドやデータベースが動いているコンピュータ（たとえば AWS の EC2）

ブラウザ

Webアプリを表示＆操作するためのソフト（Chrome 等）

これらが合わさって動いている「サービス全体」を、Webアプリケーションと呼ぶイメージです。